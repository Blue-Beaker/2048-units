<!DOCTYPE html>
<html style="width: 100%;height: 100%;">

<head>
    <meta name="viewport" content="width=device-width,height=window-height">
    <title>2048 Units</title>
</head>
<style type="text/css">
    /* .grid{
      background-color:#aaaaaa;
    } */
    .grid td {
        background-color: #222222;
    }

    body {
        background-color: #222222;
        width: 100%;
        height: 100%;
    }

    /* .area{
        border: 1px;
        border-color: #aaaaaa;
        border-style: solid;
    } */
    .cell {
        background-color: #808080;
        border-radius: 10px;
        border-style: none;
        text-align: center;
        position: absolute;
        margin: 10px;
        width: 115px;
        height: 115px;
        z-index: 3;
        transition: left 0.2s, top 0.2s;
        -webkit-transition: left 0.2s, top 0.2s;
        transition-timing-function: ease-in;
        animation: spawn 0.3s;
        animation-timing-function: ease-in;
        offset-anchor: center;
        font-size: larger;
    }

    .cellLabel {
        font-family: sans-serif;
        text-align: center;
        margin: auto;
        font-size: 2rem;
    }

    .plate {
        background-color: #333333;
        border-radius: 10px;
        border-style: none;
        z-index: 1;
    }

    div {
        color: #ffffff;
    }

    p {
        font-family: sans-serif;
        text-align: center;
        color: #ffffff;
    }

    @keyframes spawn {
        0% {
            scale: 110%;
        }

        100% {
            scale: 100%;
        }
    }
</style>

<body>
    <div class="info" style="float:left;width: 100%;">
        <div style="float: left;">
            <p style="font-size: xxx-large;margin-top: 0;">2048 Units</p>
        </div>
        <div class="plate" style="float: left;width: 100px;height: 100px;">
            <p style="text-align: center;">SCORE</p>
            <p id="score" style="text-align: center;"></p>
        </div>
        <div class="plate" style="float: left;width: 100px;height: 100px;">
            <p style="text-align: center;">COMPLEXITY</p>
            <p id="complexity" style="text-align: center;"></p>
        </div>
    </div>
    <div class="area" style="float: left;width: 510px;aspect-ratio: 1;position: relative;">
        <div id="bg" class="grid"
            style="width: 510px;height: 510px;position: absolute;border-radius: 20px;background-color: #444444;">
            <div id="bggrid" class="grid" style="width: 100%;height: 100%;position: absolute;">

            </div>
            <div id="gamegrid" class="grid" style="width: 100%;height: 100%;position: absolute;">

            </div>
        </div>
    </div>
    <div id="otherinfo" style="float: left;">
        <div class="plate">
            <p>Discovered Units:</p>
            <div id="discovered">

            </div>
        </div>
        <div class="plate">
            <button onclick="saveGame()">
                Save
            </button>
            <button onclick="loadGame()">
                Load
            </button>
            <form>
                <textarea id="leveldata">

                </textarea>
            </form>
        </div>
    </div>
</body>
<script>

    "use strict";
    const DIR_UP = 0
    const DIR_RIGHT = 1
    const DIR_DOWN = 2
    const DIR_LEFT = 3
    const gamegrid = document.getElementById("gamegrid")
    const bggrid = document.getElementById("bggrid")

    const WIDTH = 4
    const HEIGHT = 4

    var debug = false

    var score = 0
    document.getElementById("score").textContent = score

    var cells = []
    var newUnitPool = [{ m: 1 }, { s: 1 }]
    var unlockedUnits = ["m", "s"]
    var discoveredUnits = []

    //Used after every round
    var wait = false
    var cellsToDelete = []

    function getCell(x, y) {
        if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {
            return cells[y][x]
        } else {
            return undefined
        }
    }
    function setCell(x, y, cell) {
        if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {
            cells[y][x] = cell
        }
    }
    function getSide(x, y, side) {
        if (side == DIR_UP) {
            return [x, y - 1]
        }
        else if (side == DIR_DOWN) {
            return [x, y + 1]
        }
        else if (side == DIR_LEFT) {
            return [x - 1, y]
        }
        else if (side == DIR_RIGHT) {
            return [x + 1, y]
        } else {
            return undefined
        }
    }
    function getSideCell(x, y, side) {
        var [x, y] = getSide(x, y, side)
        return getCell(x, y)
    }
    function logDebug(data) {
        if (debug)
            console.log(data)
    }
    function spawnCells(count = 2) {
        var emptyCells = []
        //Get empty cells for spawning
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                if (getCell(x, y) === null) {
                    emptyCells[emptyCells.length] = [x, y]
                }
            }
        }
        //Spawn cells
        for (let index = 0; index < count; index++) {
            if (emptyCells.length == 0) {
                logDebug(`out of space`)
                return
            }
            var chosenCell = Math.floor(Math.random() * emptyCells.length);
            var [x, y] = emptyCells.splice(chosenCell, 1)[0]    //Dont spawn on same cell
            new cellGrid(x, y, newUnitPool[Math.floor(Math.random() * newUnitPool.length)])
        }
    }

    //Handle keyboard event
    function onkeydown(event) {
        if (wait) { return }
        switch (event.key) {
            case "ArrowUp" || "w":
                move(DIR_UP)
                break;
            case "ArrowDown" || "s":
                move(DIR_DOWN)
                break;
            case "ArrowLeft" || "a":
                move(DIR_LEFT)
                break;
            case "ArrowRight" || "d":
                move(DIR_RIGHT)
                break;

        }
        logDebug(event)
    }
    //Logic
    function multiply(units1, units2) {
        var units3 = {}
        for (const key in units1) { //multiply units1
            units3[key] = units1[key]
        }
        for (const key in units2) {  //multiply units2
            if (units1[key] != null) {
                units3[key] = units1[key] + units2[key]
            } else {
                units3[key] = units2[key]
            }
        }
        return units3
    }
    function divide(units1, units2) {
        var units3 = {}
        for (const key in units1) { //multiply units1
            units3[key] = units1[key]
        }
        for (const key in units2) {  //divide by units2
            if (units1[key] != null) {
                units3[key] = units1[key] - units2[key]
            } else {
                units3[key] = -units2[key]
            }
        }
        return units3
    }
    const unitNameDict = {
        m1: "m",
        m2: "m²",
        m3: "m³",
        s1: "s",
        s_1: "Hz",
        m1s_1: "m/s",
        m1s_2: "m/s²",
        kg1: "kg",
        m_3kg1: "kg/m³",
        m1s_2kg1: "N",
        m2s_2kg1: "J",
        m2s_3kg1: "W",
    }
    const unitBase = ["m", "s", "kg", "A"]
    function getUnitName(units) {
        var intstr = ""
        for (const key in unitBase) {
            var unit = unitBase[key]
            if (units[unit] && units[unit] != 0) {
                intstr += (unit + units[unit])
            }
        }
        intstr = intstr.replace("-", "_")
        if (intstr.length == 0) { return "1" }
        return unitNameDict[intstr]
    }
    function getRawName(units) {
        var name = ""
        for (const key in units) {
            name += (key + "=" + units[key])
        }
        return name
    }
    //Cell
    class cellGrid {
        constructor(x, y, units = { m: 1 }) {
            if (getCell(x, y) === undefined) {
                logDebug(`${x},${y} is out of bounds`)
                return
            } else if (getCell(x, y) instanceof cellGrid) {
                logDebug(`replacing ${x},${y}`)
                getCell(x, y).remove()
            }
            this.units = units
            this.x = x
            this.y = y
            this.cell = document.createElement("div")
            this.cell.classList.add("cell")
            gamegrid.appendChild(this.cell)
            this.updateVisuals()
            this.updatePosition()
            setCell(x, y, this)
        }
        updateVisuals() {
            this.cell.innerHTML = "<div class='cellLabel'>" + this.getName() + "</div>"
            this.cell.style.backgroundColor = "#" + this.getColor()
        }
        updatePosition() {
            this.cell.style.left = this.x * 125 + "px"
            this.cell.style.top = this.y * 125 + "px"
        }
        getName() {
            return getUnitName(this.units) || getRawName(this.units)
        }
        getColor() {
            var color = 0x808080
            if (this.units.m != null) {
                color += this.units.m * 0x272700
            }
            if (this.units.s != null) {
                color += this.units.s * 0x2700
            }
            if (this.units.kg != null) {
                color += this.units.kg * 0x270000
            }
            if (this.units.A != null) {
                color += this.units.A * 0x27
            }
            return color.toString(16)
        }
        canMerge(obj, dir) {
            if (obj instanceof cellGrid) {
                if (dir == DIR_UP) {
                    return getUnitName(divide(obj.units, this.units)) != null
                } else if (dir == DIR_DOWN) {
                    return getUnitName(divide(this.units, obj.units)) != null
                } else {
                    return getUnitName(multiply(this.units, obj.units)) != null
                }
            }
        }
        move(dir) {
            var y2 = this.y
            var x2 = this.x
            var success = 0
            while (getSideCell(x2, y2, dir) === null) {
                var [x2, y2] = getSide(x2, y2, dir)
            }
            success ||= this.relocate(x2, y2)
            var [x3, y3] = getSide(x2, y2, dir)
            success ||= this.tryMerge(x3, y3, dir)
            return success > 0
        }
        relocate(x, y) {
            if (x == this.x && y == this.y) {
                logDebug(`Already at ${x},${y}`)
                return false
            }
            if (getCell(x, y) !== null) {
                logDebug(`${x},${y} isn't empty`)
                return false
            }
            logDebug(`moving ${this.x},${this.y} to ${x},${y}`)
            setCell(this.x, this.y, null)
            this.x = x
            this.y = y
            setCell(x, y, this)
            this.updatePosition()
            return true
        }
        tryMerge(x, y, dir) {
            var cell2 = getCell(x, y)
            if (!this.canMerge(cell2, dir)) { return false }
            cell2.remove()
            var newUnits
            if (dir == DIR_DOWN) {
                newUnits = divide(this.units, cell2.units)
            } else if (dir == DIR_UP) {
                newUnits = divide(cell2.units, this.units)
            } else {
                newUnits = multiply(this.units, cell2.units)
            }
            this.relocate(x, y)
            this.remove()
            new cellGrid(x, y, newUnits)
        }
        remove() {
            setCell(this.x, this.y, null)
            cellsToDelete.push(this.cell)
            this.cell.style.zIndex = 2
        }
    }
    //init scripts
    function init() {
        cells = []
        for (let y = 0; y < HEIGHT; y++) {
            var row = []
            for (let x = 0; x < WIDTH; x++) {
                var cell = document.createElement("div")
                cell.classList.add("plate")
                cell.style.width = "115px"
                cell.style.position = "absolute"
                cell.style.height = cell.style.width
                cell.style.float = "left"
                cell.style.margin = "10px"
                cell.style.left = x * 125 + "px"
                cell.style.top = y * 125 + "px"
                bggrid.appendChild(cell)
                row[x] = null
            }
            cells[y] = row
        }
    }
    function clear() {
        while (bggrid.hasChildNodes()) {
            bggrid.removeChild(bggrid.childNodes[0])
        }
        while (gamegrid.hasChildNodes()) {
            gamegrid.removeChild(gamegrid.childNodes[0])
        }
        init()
    }
    function newGame() {
        spawnCells(2)
        updateRound()
    }

    //Move all cells in grid
    function move(dir) {
        var success = 0
        if (dir == DIR_UP) {
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    trymove(x, y, dir)
                }
            }
        } else if (dir == DIR_DOWN) {
            for (let y = HEIGHT - 1; y >= 0; y--) {
                for (let x = 0; x < WIDTH; x++) {
                    trymove(x, y, dir)
                }
            }
        } else if (dir == DIR_LEFT) {
            for (let x = 0; x < HEIGHT; x++) {
                for (let y = 0; y < WIDTH; y++) {
                    trymove(x, y, dir)
                }
            }
        } else if (dir == DIR_RIGHT) {
            for (let x = HEIGHT - 1; x >= 0; x--) {
                for (let y = 0; y < WIDTH; y++) {
                    trymove(x, y, dir)
                }
            }
        }
        if (success > 0) {
            updateRound()
            wait = true
            setTimeout(() => {
                spawnCells(1)
                afterRound()
                wait = false
            }, 200);
        }
        function trymove(x, y, dir) {
            if (getCell(x, y) instanceof cellGrid) {
                if (getCell(x, y).move(dir)) {
                    success += 1
                }
            } else {
                return false
            }
        }
    }

    //Update when doing a round
    function updateRound() {
        var complexity = 0
        for (const y in cells) {
            var row = cells[y]
            for (const x in row) {
                var cell = row[x]
                if (cell instanceof cellGrid) {
                    for (const key in cell.units) {
                        var power = cell.units[key]
                        complexity += Math.abs(power)
                    }
                    var name = cell.getName()
                    if (!discoveredUnits.includes(name)) {
                        pushDiscovered(name)
                    }
                }
            }
        }
        score = Math.max(score, complexity)
        document.getElementById("complexity").textContent = complexity
        document.getElementById("score").textContent = score
    }
    function pushDiscovered(name) {
        discoveredUnits.push(name)
        var newDiscovered = document.createElement("div")
        newDiscovered.classList.add("plate")
        newDiscovered.innerHTML = "<p>" + name + "</p>"
        document.getElementById("discovered").appendChild(newDiscovered)
        unlockNewUnitsWhenReady()
    }
    function unlockNewUnitsWhenReady() {
        if (!unlockedUnits.includes("kg") && discoveredUnits.length >= 8) {
            newUnitPool.push({ kg: 1 })
            unlockedUnits.push("kg")
        }
        if (!unlockedUnits.includes("a") && discoveredUnits.length >= 13) {
            newUnitPool.push({ A: 1 })
            unlockedUnits.push("a")
        }
    }

    //Update after completing a round
    function afterRound() {
        for (const y in cells) {
            var row = cells[y]
            for (const x in row) {
                var cell = row[x]

                if (cell instanceof cellGrid) {
                    cell.updateVisuals()
                }
            }
        }
        for (const i in cellsToDelete) {
            gamegrid.removeChild(cellsToDelete[i])
        }
        cellsToDelete = []
    }

    //save and load
    function serialize() {
        var cellsToExport = []
        for (const y in cells) {
            var row = cells[y]
            for (const x in row) {
                var cell = row[x]
                if (cell instanceof cellGrid) {
                    cellsToExport.push({ x: cell.x, y: cell.y, units: cell.units })
                }
            }
        }
        return { id: "2048units_savedata", cells: cellsToExport }
    }
    function saveGame() {
        document.getElementById("leveldata").value = (JSON.stringify(serialize()))
    }
    function loadData() {
        return JSON.parse(document.getElementById("leveldata").value)
    }
    function loadGame() {
        clear()
        init()
        var savedData = loadData()
        if (savedData.id != "2048units_savedata") return
        for (const i in savedData.cells) {
            const cell = savedData.cells[i]
            new cellGrid(cell.x, cell.y, cell.units)
        }
        updateRound()
    }
    init()
    newGame()
    window.addEventListener("keydown", onkeydown)
</script>

</html>